<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Chat OpenRouter</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { margin: 0; background: #343541; font-family: 'Segoe UI', sans-serif; display: flex; justify-content: center; height: 100vh; }
        .chat-wrapper { width: 100%; max-width: 850px; display: flex; flex-direction: column; height: 100vh; }
        .messages { flex: 1; overflow-y: auto; padding: 20px; }
        .message { margin-bottom: 25px; line-height: 1.6; color: #ececf1; }
        .user { text-align: right; background: #444654; padding: 10px 15px; border-radius: 10px; margin-left: auto; max-width: 80%; }
        .assistant { background: #444654; padding: 20px; border-radius: 8px; border: 1px solid #565869; }
        /* Corrige tabelas e c√≥digos que "vazam" da tela */
        .assistant table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        .assistant th, .assistant td { border: 1px solid #666; padding: 8px; text-align: left; }
        .assistant pre { background: #000; padding: 15px; overflow-x: auto; border-radius: 5px; }
        .copy-btn { margin-top: 10px; background: #19c37d; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; color: white; }
        .input-area { display: flex; padding: 20px; background: #40414f; gap: 10px; }
        input { flex: 1; padding: 15px; border-radius: 5px; border: none; background: #40414f; color: white; border: 1px solid #565869; outline: none; }
        button.send-btn { padding: 0 20px; border-radius: 5px; border: none; background: #19c37d; color: white; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

<div class="chat-wrapper">
    <div class="messages" id="messages"></div>
    <div class="input-area">
        <input id="userInput" placeholder="Mande sua d√∫vida..." autofocus />
        <button class="send-btn" onclick="sendMessage()">Enviar</button>
    </div>
</div>

<script>
const messagesDiv = document.getElementById("messages");
const userInput = document.getElementById("userInput");

let conversation = JSON.parse(localStorage.getItem("chat_history")) || [
    { role: "system", content: "Voc√™ √© um assistente especialista. Use Markdown." }
];

function addMessage(content, role) {
    const div = document.createElement("div");
    div.classList.add("message", role);
    const inner = document.createElement("div");
    inner.innerHTML = role === "assistant" ? marked.parse(content) : content;
    div.appendChild(inner);
    
    if (role === "assistant") {
        const btn = document.createElement("button");
        btn.className = "copy-btn";
        btn.innerText = "üìã Copiar";
        btn.onclick = () => {
            navigator.clipboard.writeText(div.getAttribute("data-raw") || content);
            btn.innerText = "‚úÖ";
            setTimeout(() => btn.innerText = "üìã Copiar", 1000);
        };
        div.appendChild(btn);
    }
    
    messagesDiv.appendChild(div);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    return inner;
}

async function sendMessage() {
    const text = userInput.value.trim();
    if (!text) return;
    userInput.value = "";

    addMessage(text, "user");
    conversation.push({ role: "user", content: text });

    const assistantDiv = addMessage("", "assistant");
    const parentWrapper = assistantDiv.parentElement;
    let fullText = "";

    try {
        const response = await fetch("/api/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                model: "openrouter/free",
                messages: conversation,
                stream: true
            })
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let partialChunk = ""; // Para lidar com JSONs cortados no meio

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            // Acumula o que veio da stream
            partialChunk += decoder.decode(value, { stream: true });
            
            const lines = partialChunk.split("\n");
            // Mant√©m a √∫ltima linha no buffer porque ela pode estar incompleta
            partialChunk = lines.pop();

            for (const line of lines) {
                const trimmed = line.replace(/^data: /, "").trim();
                if (!trimmed || trimmed === "[DONE]") continue;

                try {
                    const json = JSON.parse(trimmed);
                    const content = json.choices[0]?.delta?.content || "";
                    fullText += content;
                    
                    // Renderiza o markdown atualizado
                    assistantDiv.innerHTML = marked.parse(fullText);
                    parentWrapper.setAttribute("data-raw", fullText);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                } catch (e) {
                    // Se falhou o parse, a linha provavelmente est√° incompleta, 
                    // volta ela para o buffer (embora o pop/push j√° ajude)
                    console.error("Erro no parse do stream", e);
                }
            }
        }

        conversation.push({ role: "assistant", content: fullText });
        localStorage.setItem("chat_history", JSON.stringify(conversation));

    } catch (err) {
        assistantDiv.innerText = "Erro: " + err.message;
    }
}

// Atalho Enter
userInput.addEventListener("keypress", e => { if(e.key === 'Enter') sendMessage(); });

// Carrega hist√≥rico
if(conversation.length > 1) {
    conversation.forEach(m => { if(m.role !== 'system') addMessage(m.content, m.role); });
}
</script>
</body>
</html>
